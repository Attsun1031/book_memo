## クラス
クラスは、あるデータとそれを処理するロジックのまとまりを表現する。

## シンプルなスーパークラス名
* 命名には簡潔性と表現力のジレンマが生じる。これを解決するのが適切なメタファー。

    例：描画フレームワークで描画されるオブジェクトにDrawingObjectと名付けていたが、描画されるものは図形のようなものだ、というメタファーによりFigureになった。

* 重要なクラスにはひとつの単語から成る名前を見つけたい。

## 修飾的なサブクラス名
* サブクラス名の役割は、どのように似ていてどのように違うのか、を表現すること。
* スーパークラス名の前に修飾語をつける。長すぎず短すぎず。
* ただし、サブクラスが重要な概念を表す場合はシンプルな名前をつける。

## 抽象インターフェース
* 抽象インターフェースとは「実装のない操作の集合」で、Javaではインターフェースか抽象クラスとして表現される。
* インターフェースを実装から分離することで、実装を隠蔽して柔軟性を持たせる。
* しかし、インターフェースを作るコスト（命名、整理、デバッグ等々）を最小化するため必要のない柔軟性のためにインターフェースを定義することはしない。

### インターフェース
* 抽象インターフェースの表現方法の一つ。
* あるモジュールが行う操作のみを列挙し、実装については関知しないことを表現する。

### 抽象クラス
* 抽象インターフェースの表現方法の一つ。
* 実装を保持することができるので、インターフェースそのものの変更や追加に対しても対応できる。

### 別バージョンのインターフェース
* インターフェースの追加は既存実装に対して影響を与える。
* インターフェースを継承した別インターフェースを定義することで、既存のインターフェースを保持しつつ新たなインターフェースを提供することができる。

## バリューオブジェクト
* 数学的な値のように、不変なオブジェクト
* 状態を持つオブジェクトと不変なオブジェクトとの境界線を引き、状態を持つオブジェクトが不変なオブジェクトを管理する。

## 特化
* ロジックの類似点と相違点を明確に表現する。

## サブクラス
* スーパークラスとの類似点と相違点を伝える。
* サブクラス化には以下の問題が伴い、継承改装が深くなるとそれぞれが悪化する。
     - 一度しか使えない
     - スーパークラスの理解が必要。
     - スーパークラスの変更にリスクが伴う。
* 特に悪質なのは並列の階層。片方の階層にサブクラスを加えた場合、もう片方にも加えなければならないようなもの。
* スーパークラスのメソッドが大きいとサブクラスでのオーバーライド時に重複が生じやすいので、メソッドは細かくしておく。
* サブクラスを適用する際は、サブクラス、条件分岐、委譲のいずれが適しているか考えること。

## 実装クラス
* メソッドをオーバーライドすることで多態性を実現する

## 内部クラス
* 局所的に使用されるコードをまとめる

## インスタンス固有の振る舞い
* インスタンスごとにロジックを変動させる

### 条件分岐
* インスタンス固有の振る舞いを実現するシンプルな形式。
* サブクラスや委譲と比べ、すべてのロジックが局所的なので見やすい。
* バリエーションの追加が必要な場合は、条件分岐の追加と実装の追加の両方が必要となる。
* 同じ条件分岐が複数ヶ所に現れやすい

### 委譲
* インスタンス固有の振る舞いを実現する方法の一つ。いくつかあるオブジェクトのうち一つに処理を委譲する。
* ロジックの実装は各クラスに散るので局所的でなくなる。

### プラガブルセレクタ
* リフレクションを利用することでロジックを変動させる。
例：テストフレームワークでは、各テストクラスにrunTestを実装させるよりは、testxxxというメソッドを動的に取得して実行するほうが各テストを実装しやすい。
* メソッド呼び出しが暗黙的になるので乱用すべきではない。

## 匿名内部クラス
* 局所的にあるクラスのメソッドをオーバーライドする

## ライブラリクラス
* どのオブジェクトにも属さないスタティックな操作をまとめたユーティリティクラス。インスタンス化されない。
* オブジェクト指向の利点を失うのでできるだけ避ける。
