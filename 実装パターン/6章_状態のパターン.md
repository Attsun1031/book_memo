# 序論
オブジェクトは、外部の世界に対して示される振る舞いと、その振る舞いを支えるために使用される状態の、便利なパッケージ。
状態が小さなスコープに収まれば、状態に関するコード変更の影響はそのスコープ内に収まるので保守性が増す。

# パターン
## 状態
オブジェクト指向言語では、状態を小さな塊に分け、塊同士のアクセスを厳密に制限することで、状態の変化をその持ち主がコントロールできるようにする。

## アクセス
* 状態に関する可読性と柔軟性を上げるには、格納と計算を明確に分けることが必要。
* フィールドにpublicなアクセサを提供することでオブジェクトの独立性は失われる。

## 直接アクセス
* 変数への直接アクセスは表現が明確になる。
* ただし、柔軟性を犠牲にしている。
* 実装の詳細を反映するので、意図が伝わらなくなる。

    例えば、doorRegister変数に1を割り当てるとドアが開く実装の場合、

        doorRegister = 1

    よりも、

        openDoor()

    や

        door.open()

    のほうがわかりやすい。

## 間接アクセス
* 明確性を犠牲にして柔軟性を実現する

    getter/setterであれば明確性はさほど失われないが。（アクセサでなにしてるかわからんってのはあるけど）

## 共通の状態
* 複数の計算が同じ要素を要求する場合はフィールドにする。
* オブジェクトの操作を呼び出すのに何が必要かはっきりする
* オブジェクトが操作する対象がはっきりする
 * 各フィールドはスコープと生存期間を揃えること。あるメソッドに有効な値を追加したい場合は、引数としてとらせるかヘルパーオブジェクトを使用することで避ける。

## 可変の状態
* 操作や使われ方に応じて、同じオブジェクトが異なるデータ要素を必要とする場合や、あるフィールドの値によって必要とされる状態が異なる場合は、マップをフィールドとして持つことで様々な値を管理できるようにする。
* 柔軟性の代わりに明確さを犠牲にする。

## 外部の状態
・あるオブジェクトに関連する値が、プログラムの一部で必要となっても全体で必要ない場合、他のフィールドとの対称性を侵害する場合は外部のオブジェクトをキー、そのオブジェクトが使用するデータをバリューとするマップを持つ。

## 変数
* 変数の生存期間とスコープは揃える
* 基本的にはローカル変数とフィールドのみを使用することで、変数名にスコープ情報を持たせる必要がなくなる。変数宣言が近くにあればローカル、なければフィールドということになるので。

## ローカル変数
* できるだけ内側のスコープで、使用される直前に宣言する
### ローカル変数は以下の役割で使用される

#### コレクター
変数の戻り値となる値。resultなど、名称でコレクターであることを表現する。

#### カウント
他のオブジェクトの数を収集する特殊なコレクター

#### 説明
複雑な式がある場合、その式の一部をローカル変数に代入することで可読性を上げる。これがそのままヘルパーメソッドと転じる場合もある。

#### 再利用
同じ値を複数ヶ所で使用する場合。現在時刻を複数のオブジェクトにセットするなど。

#### 要素
走査されるコレクションの各要素。for eachWord in wordsのeachWord。

## フィールド
フィールドのスコープと生存期間はそのオブジェクトと同じなので、冒頭あるいは末尾にまとめて宣言する。

### フィールドは以下の役割で使用される
#### ヘルパー
オブジェクト内の多くの箇所で使用されるオブジェクトへの参照。多くのメソッドで引数として渡されるオブジェクトがある場合はヘルパー化することを検討する。

#### フラグ
論理型のフラグフィールドは、このオブジェクトには２種類の動作がある、ということを表現している。setterがある場合、生存中に動作が変更可能であることを表現する。フラグの判断が何度も出る場合はストラテジーへの変換を検討する。

#### ストラテジー
オブジェクトの計算の一部に複数パターンあることを表現する。

#### 状態
オブジェクトの振る舞いの一部が委譲されるという点でストラテジーと同じだが、状態は自らの状態を自ら変化させる（ステイトマシン）

#### コンポーネント
そのオブジェクトが所有するデータ。

## 引数
* あるオブジェクトから別のオブジェクトへ状態を伝えたい場合、引数として渡す。
* フィールドとして永続的に持たせるよりも結合度が弱まる。

## コレクティングパラメータ
* メソッド呼び出しを何度か行い、それぞれの結果を収集・マージする処理では、格納用のオブジェクト（コレクションなど）を渡す。
* 整数値の場合は戻り値で受けてもマージは楽だが、オブジェクトの場合はマージに手間が掛かる。

## オプション引数
デフォルト値を持った引数。

## 可変引数
引数の数が決まらない場合。コレクションでも良いが、呼び出し側でコレクションを生成する手間がある。

## パラメータオブジェクト
* 複数ヶ所で同じ引数の集団が存在する場合、それをまとめてオブジェクトとする。
* その引数集団のみを使っている処理がある場合、操作はパラメータオブジェクトに移動する。

## 定数
* オブジェクト内の複数ヶ所で必要となるが、値が変化しない場合。
* マジックナンバーを回避する。
* インターフェースのバリエーションを表現する。

setJustification(Justification.CENTERED)
など。定数を増やすだけでインターフェースを壊さずに実装のバリエーションを追加できる。
ただし、メソッド名を変えて別メソッドに切り出したほうがわかりやすくなりやすい。上記のコードなら、
justificationCentered()
となる。

## 役割を示す名前
* 変数は、役割を表す名前をつけるべき。
* 変数には他にも伝えるべき情報があるが、型は型宣言やIDEの機能、スコープはローカル変数とフィールドのみを基本的に使うようにすれば、変数名にそれらの情報をもたせずとも理解できる。
* 略語は間違った節約。変数は書かれることよりも読まれることのほうが何倍も多い。
* 変数名が長すぎる場合、「なぜ他の変数と区別するためにこんなにたくさんの単語が必要なのか？」を問い直す。

## 宣言される型
* 型はできるだけ汎用的な型を宣言すること。あとで具象クラスを変更しやすい。
* ただし、汎用的すぎる型は用途が限定されなくなり不安定になる。

## 初期化
変数使用前に変数を既知の状態へ置くプロセス。

## 早期初期化
* 宣言時、もしくはオブジェクト生成時に変数を初期化する。
* 宣言時に初期化されれば型と実際の型の双方を知ることができる。

## 遅延初期化
初期化時に設定する値の計算コストが高い場合、変数の利用時に初期化を行う。初期化コードはgetterに置く。

    class Person:
      def __init__(self):
        self.__salary = None
      @property
      def salary(self):
        if salary is None:
          # 初期化コード
        return self.__salary

可読性が落ちるので乱用しないこと。