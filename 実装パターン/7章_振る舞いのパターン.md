## 制御フロー
* 計算をステップのシーケンスとして表現する

## メインフロー
* 制御のメインフローを明確に表現する

## メッセージ
* メッセージ送信によって処理の詳細を隠蔽する。
* 「この処理の詳細は変更され得る」ということを伝える。

## 選択メッセージ
* メッセージの実行者を動的に変動させる（ポリモーフィズム）
* 計算内容やバリエーションに変更の余地がない場合は適用しないこと。可読性が下がる。

## 二重ディスパッチ
* 選択メッセージを受信したオブジェクトが、その実装ごとに別のオブジェクトに送信するメッセージを変動させる。
* 多段階の変動性を表したい場合。
* 重ねすぎると複雑になる。
* 一つ目のメッセージを受信した型が、次のメッセージを受信するクラスに影響を与えるため柔軟性が損なわれる。  
下の例ではbrushのメソッドがShapeごとに用意されている。  
例：shapeごとにbrushされる内容を変えたい

		public void displayShape(Shape subject, Brush brush) {
 	    	subject.displayWith(brush);
		}


		# class Oval
		public void displayWith(brush) {
		     brush.displayOval(this);
		}


		# class Rectangle
		public void displayWith(Brush brush) {
    		 brush.displayRectangle(this);
		}

## 分割（直列）メッセージ
* 複雑なロジックをステップごとに分割し、その分割されたステップを呼び出す。
* 各ステップの引数リストが長くなる場合、メソッドオブジェクト化してステップをインラインにする。

## 反転メッセージ
* ある制御フローで各メッセージを同じ受信者に送信することで対称性を上げる。

## 招待メッセージ
* 複数の実装が可能となるメッセージを送信することで、プログラマーにバリエーションの追加が可能であることを示唆する。（新しい実装を”招待”する）
* abstractなメソッドを送信するなど。

## 説明メッセージ
メッセージに、そのメッセージの目的を示唆するような名前をつけ、目的を実現する方法は内部に隠蔽する。  

例：highlight（強調する）が目的で、reverseはその方法である。reverseを直に呼び出すよりも目的がはっきりする。

	void highlight(Rectangle area) {
     	reverse(area);
	}
	
また、あるコードに意図を表すコメントをつけるのなら、それをメソッド化して名前でその目的を表す。  
メソッドの実装が非常に単純なものでも可読性の面で効果がある。

## 例外フロー
* 例外フローは、メインフローの明確性を阻害しないようにする。

## ガード条件
* 制御フローで例外的な状況が発生した場合は早期リターンを行う。
* if-then-elseはそれぞれが同じくらい重要な制御フローであることを示唆する一方、ガード条件では早期リターンされる制御フローがそうでないものよりも重要でないことを示唆する。
* ネストした条件分岐は不具合の原因となりやすい。
* ループ内でのcontinueもガード条件の一つ。

## 例外
* 例外は、発生箇所からキャッチする箇所の間にあるすべての処理に影響を与えるため、読み進めるのが難しい。
* 例外を使わないとシンプルにメインフローを伝えられない場合のみ例外を使う。

## チェック例外
* 例外処理の記述をコンパイラが強制することによって、例外の処理漏れをなくす。

## 例外の伝播
* 下位の例外を、メッセージ送信者に意味のあるメッセージを持った例外にラップしてraiseする。
