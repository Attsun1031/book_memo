## 複合メソッド
* いくつかの他のメソッドを呼び出す制御フローを持つメソッド。
* 各メソッド呼び出しの抽象度を揃えること。
* 大きなメソッドは全体を把握するのに役立つが、詳細の把握が難しい。  
密接に関連する詳細はひとつにまとめ、関連しない詳細とは分けておくと良い。
* 閲覧性と要約性を同時に満たすようなメソッドの粒度にすること。
* メソッドの大きさは特化の際にも問題となる。  
適切な大きさでないと、特化を行う際に親メソッドをコピーして一部だけ書き換えたり、複数のメソッドをオーバーライドしなければならなくなる。

## 意図を示す名前
* メソッド名は意図のみを伝え、実装の詳細は伝えないこと。呼び出す側は実装の詳細を意識していない。

## メソッドの可視性
* メソッドの公開範囲と柔軟性は反比例する。非公開なものほどスコープが限定されている分、柔軟性が高い。
* 公開されているメソッドが少ないと、クライアントからの使い勝手が下がる。
* 可視性の意味
     * パブリック  
パッケージの外側でもこのメソッドは役立つ。
     * プロテクテッド  
サブクラスでの再利用が可能
     * プライベート  
高い柔軟性を持つ。外部から利用する価値はない。

## メソッドオブジェクト
* 複雑なメソッドを明確にするのに役に立つ。
* 長い引数リストや多くの一時変数があるメソッドで、どこをメソッド抽出しても長い引数となってしまうメソッドが
候補。
* 手順
	1. メソッド名にちなんだ名前をもつクラスを作成する。
	1. 引数、一時変数をフィールド化する
	1. 元のメソッドが使用していた引数とフィールドを引数としたコンストラクタを作る。
	1. メソッド本体を新しいクラスのメソッドにコピーする。  
これを行うと、一時変数等はフィールドに格納されているのでメソッド抽出等のリファクタリングが容易になる。

## オーバーライドメソッド
* 特化を表現するためにメソッドをオーバーライドする。

## オーバーロードメソッド
* 異なる引数で同じ名前のメソッドを宣言することで、「このメソッドには選択可能な複数の形式がある」ということを伝える。
* オーバーロードメソッドの実行目的はすべて同じにすべき。新しい意図には新しい名前をつけるべき。

## メソッドが返す型
* 静的型付け言語では、戻り値の型はできるだけ抽象的にする。実装の詳細を隠蔽する一つの手段でもある。

## メソッドのコメント
* できるだけ名前と構造で意図を表現したいが、それでもはっきり伝わらない場合にだけコメントをつける。
* コメントを付ける場合、コードとコメントの一貫性の維持にも気を配る。

## ヘルパーメソッド
* 大きなメソッドを複数の小さいヘルパーメソッドに分割する。ヘルパーメソッドはプライベートもしくはプロテクテッドとなる。
* 意図をメソッド名で表し詳細を隠蔽することで、大きなメソッドの可読性を上げる。

## デバッグ出力メソッド
* toStringにより（プログラマのための）オブジェクトの詳細を表示する。

## 変換
* ある型のオブジェクトから別の型のオブジェクトへの変換を明確に表現する。

## 変換メソッド
* 変換の数が限られているのであれば、変換元のオブジェクトに変換メソッドを持たせる。
* 変換元から変換先のオブジェクトに依存が発生する。変換候補が無限にある場合は別の方法を考える。

## 変換コンストラクタ
* 変換元オブジェクトを受け取り、変換後のオブジェクトを返すコンストラクタ
* 変換元オブジェクトに変換メソッドが集中しないという利点がある。
* ファクトリメソッドとして変換コンストラクタを用意することで、抽象的な型のオブジェクトを返すことができる。

## 生成
* オブジェクトを生成するということは、「ある計算を行うには、ある状態が機能します。その詳細については、今のところ重要ではありません。」と表明することである。

## 完全なコンストラクタ
* オブジェクトが計算を行うのに必要となるすべてのパラメータを受け取るコンストラクタを作る
* ユーザーに事前条件を表明することになる。
* 空のコンストラクタでオブジェクトを作ってsetterでセットしていく方法は柔軟性があるが、事前条件が明白でない。
* コンストラクタは、ユーザーに具象クラスの使用を強制する。抽象的な型を扱いたいのならばファクトリメソッドを導入する。
* 事前条件に複数のバリエーションが存在する場合には複数のコンストラクタを作る。ただし、不変の部分はマスターコンストラクタに委譲することでコンストラクタの追加を簡単にすること。

## ファクトリメソッド
* 抽象的な型を返すことができる他、意図に沿った名前を与えることができる。（コンストラクタではクラス名を名前として使用しなければならない）
* プログラマは普通、ファクトリメソッドに対して何らかの意図を見ようとするので、インスタンス生成時にコンストラクタでは対処できない複雑な処理が行われる場合にのみ導入する。

## 内部ファクトリ
* 内部で利用するヘルパーオブジェクトの生成が複雑になる場合に導入する。
* 特に、遅延初期化の際の初期化処理を内部ファクトリとして抜き出すとわかりやすい。  
例

		getX() {
     		if (x == null)
          		x = computeX();     // 内部ファクトリ
		     return x;
		}

## コレクション用アクセサメソッド
* オブジェクトが保有しているコレクションデータを返すgetterは柔軟性を提供するものの、オブジェクトが知らないところでその内部状態が破壊されてしまうという問題もある。
* addXXXやgetXXXCountなど、限定された意味のあるアクセサのみを提供するのが保守性の観点からは良い。

## 論理設定値メソッド
* 例えばsetValid(bool)というsetterがある場合、valid(), invalid()という2つのメソッドを定義したほうが可読性が高く、ある状態がセットされている箇所を発見するのも楽。ただし、
if (論理式):
  valid()
else:
  invalid()
となっている場合が多い時は冗長なのでsetValidに変えたほうが良い。

## クエリメソッド
* isXXXやhasXXXなど、外部のオブジェクトに自身の状態を提供する。
* 別のオブジェクトの状態に依存するのは保守性が低下してしまうので、他のオブジェクトの状態に依存するコードが増えている場合は設計を見直すこと。

## 等価性メソッド
* 同一性が問題とならないオブジェクト間の等価性を比較する。

## getterメソッド
* getterメソッドをパブリックにしたい場合、データとロジックを一箇所にまとめるという原則が崩れている可能性があるので、getterを呼び出しているロジックを移動する。
* 例外は、ある一連のアルゴリズムが別のオブジェクトに置かれている場合と、あるパブリックメソッドがたまたまフィールド値をそのまま返している場合。

## setterメソッド
* setXXXというsetterメソッドには、クライアントからの意図が全くわからないので、クライアントの視点から名前を付け直したほうが良い。その値を設定することで、どんな問題を解決しているかがわかるように。
例えば、
paragraph.setJustification(Paragraph.CENTERED);
よりも、
paragraph.centered();
のほうが意図が伝わっている。(centeredの実装はsetJustificationを呼んでいる。）
* 内部でsetterメソッドを使う場合は、ある状態が変化した場合に同時に発生させるべきアクションを局所化できるので有効。

## 安全なコピー
* オブジェクトの持つ、コレクション等のオブジェクトデータを返す際、コピーを返すことで別名参照の問題を回避する。
* オブジェクトの内部状態にアクセスする要求がある場合は設計上の問題が生じている可能性があるので、一時的な手段として安全なコピーを利用する。