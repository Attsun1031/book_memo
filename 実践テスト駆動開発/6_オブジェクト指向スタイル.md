# 保守を考えて設計する
### 関心事を分離する
同じ理由で変更することになりそうなコードはまとめておく。

### 抽象度を高める
抽象度の高い表現は物事をシンプルにしてわかりやすくする。

## ポートとアダプタ
上記２つのフォースを一貫して適用すれば、アプリケーションの構造はコーバーンが「ポートとアダプタ」アーキテクチャと名づけたものに近づく。

これは、ドメインモデルとUIやDBといった外部要素を切り離すため、ドメインモデルが外部との関係をするインターフェースを定義し（ポート）、これを各外部要素用に変換する層（アダプタ）を置く。
DDDにおける腐敗防止層に似ている。

## 内部と外部の境界
ピア（直接のコミュニーケーション相手）から内部に対するアクセスをAPIによってカプセル化し、詳細を隠蔽したい。どうやるか？

### 単一責任原則
オブジェクトが持つ責務をたったひとつに限定する。オブジェクトが何をしているかをAnd・Or・Butなどを使って説明している場合、複数の責務を持っている可能性がある。

### ピアのステレオタイプ
オブジェクト同士が何を伝えているかはおおまかに以下3種類に分類できる。

#### 依存
あるオブジェクトが自身の責務を果たすためにピアに対して要求するサービス。
依存を持つピアは、その依存先なしには生成できないようにしなければならない。つまり、コンストラクタで依存するオブジェクトを受け取るようにする。

#### 通知
あるオブジェクトの情報を取得し続ける必要のあるピア。
通知する側は誰に通知するかを知らないし、通知される側は具体的にどうやって通知されるかは知らない。

#### 調整
複数のオブジェクトを調整するピア。

## カプセル化と情報隠蔽の違い
### カプセル化
オブジェクトの振る舞いに対して、APIを通じてしか影響を与えられないようにすること。影響範囲を絞るのに重要。

### 情報隠蔽
オブジェクトが機能をどう実装しているかをAPIによる抽象化の背後に隠すこと。

## コンポジットは構成要素の総体よりもシンプルにする
複数のオブジェクトからなるコンポジットは、複数のオブジェクトから成り立っていることを使う側に意識させないような、抽象度の高いシンプルなAPIを提供すること。
例えば、金額と通貨記号からなるテキストは、金額と通貨記号を別々に設定させるのではなくMoneyという抽象的な単位を設定させるようにする。

## コンテキストからの独立
あるオブジェクトが情報を隠蔽しすぎていないか。オブジェクトが実行環境に関する知識を持たないこと。
