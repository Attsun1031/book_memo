# テストファーストは設計にどう役立つか
## 「どうやって」よりも何を先に意識できる
* 「なにを」実装するかを先に意識することで、適切な抽象度を保てる。
 * ユニットテストの意図がはっきりしない場合、対象が複数の概念を混同している可能性がある。
 * オブジェクトの外から見えるべきことはなにかを決めやすくなる

## ユニットテストの保守性を考えることは設計を洗練する
 * 大きなユニットテストは保守しづらいので、対象を小さな単位に分解していく過程で設計が洗練されていく。

## 依存ピアを渡すことでオブジェクトがコンテキストから独立する
 * オブジェクトをユニットテスト用に構築するには依存ピアを渡す必要がある。つまり、何に依存しているかを知ることになる。
  * 外部からそのオブジェクトのコンテキストを指定できるようになる。

# 分類よりもコミュニーケーション
あるオブジェクトが他のオブジェクトとどうコミュニーケーションするかは、テストでモックオブジェクトを活用することで明示できる。

# 値型
## 値型のメリット
ある属性値を値型のオブジェクトとして切り出すことで、

* その値と関係しているオブジェクトをすぐに見つけられる
* 同じ文字列でも別の値型なら別のものとして表現できる
* 値に対する振る舞いを配置する格好の場所となる

## 値型のテクニック
### 分解
あるオブジェクトが複雑になったら、振る舞いの凝集した単位を分解する

### 発芽
コードの中で新しい概念に印を付けたいと思った場合、その概念に関連するフィールドをラップするプレースホルダー型を導入する。  
また、別のオブジェクトを必要とするあるオブジェクトを実装する時、テストでは別のオブジェクトをモックする。  
このとき、そのオブジェクトとテスト対象のオブジェクトがどのようなサービスをどのようにコラボレートするかを明確にすることになる。  
こうして徐々にオブジェクト構造を設計していく。  
モックオブジェクトについては何をするサービスを持つかに集中して考えるようになるので、抽象度の高いインターフェースが自然と発見される。

### 包括
特定のグループの値が常に一緒に使われる時、それらを包括する値型を作る。振る舞いも移動し、値をカプセル化すれば設計は更に洗練される。

## クラスについて
設計において重要なのはオブジェクト間のコラボレーションであってその構造ではない。ロール（インターフェース）の実装がクラスであり、クラスは実装の詳細だという考え方。  
継承よりも委譲のほうが柔軟なので推奨。

# その他
実際に実装してみることほど設計を揺さぶるものはない。最初から正しく設計することはかなり難易度が高いので、重要な領域のコードに初期の段階から取り組むことで設計を改善させていくべき。
