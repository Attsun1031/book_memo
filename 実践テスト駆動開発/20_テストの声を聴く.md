# テストしづらいコードのパターン
## オブジェクトのモックを作りたいが置き換えづらい
### シングルトンは依存性
シングルトンやグローバルオブジェクトは実装上便利だが、モックで置き換えるのが難しくなる。  
特に`Date`などのosと結びつくオブジェクト。

#### 解決方法
グローバルオブジェクトを使うのではなく、それをコンストラクタで受けられるようにする。  
これにより、依存関係も明確になる。

### 手続きからオブジェクトへ
テスト対象に存在する、そのテスト対象とは直接的に関係ない手続きをオブジェクト化して隠蔽する。

### 暗黙のものであっても依存は依存
グローバルなオブジェクトを使うと、あるオブジェクトが何に依存しているのかがわかりづらくなる。


## ログ出力はフィーチャー
ログには以下の2種類がある

* サポートログ（error or info）  
障害調査や稼働中のシステムの運用管理
* 診断ログ（debug or trace）  
開発中のシステムの内部状態を理解する

サポートログは誰かの要求にもとづいて作るものなので、TDDでしっかりと作るべきもの。

### ログよりも通知
ログの出力要求と、メッセージのレンダリング・出力は以下のように分離すべき。

	location = tracker.getCuurentLocation()
	for filter in filters:
		filter.selectFor(location)
		# ログ出力とレンダリングはせず通知するのみ。
		support.notifyFiltering(tracker, location, filter)
		
ある責務を持つオブジェクトにログのレンダリングという別の責務を負わせることになる。

### 得られるメリット
過剰なように感じるが、以下のようなメリットもある。

* レンダリングが集中化するのでフォーマットを揃えやすい
* エラー通知の方法を実装時に分離して考えられる

## 具象クラスのモック
テスト対象クラスが依存するクラスのサブクラスを作って、そのサブクラスが持つ特定のメソッドをオーバーライドすることでモックを実現する手法。  
テスト対象とその依存クラスの境界が曖昧になってしまうのでモックを使うべき。

### 緊急時にはガラスを割れ
直接モックするのが難しい3rd partyのコードなどは、この手法を使ってしまったほうが良いケースも多い。

### 内部実装をオーバーライドしない
内部実装をオーバーライドすると、テストが実装に依存してしまうのでよくない。

## 値をモックしない
イミュータブルな値オブジェクトをモックしても意味のないケースがほとんど。直越インスタンス化して使ったほうが良い。  
インスタンス生成が難しいならビルダーを作ったほうが良い。

## 肥大化したコンストラクタ
依存関係をコンストラクタ引数として取り出していくとコンストラクタ引数が肥大化する。  
この現象自体は悪いことではないが、関連のあるオブジェクト同士をまとめて新しいオブジェクトにすることが必要。

### 抽出のコツ
まず、以下２つの条件に当てはまるオブジェクトを探す。

* クラス内で同時に使われている引数はいないか
* それらの生存期間は同じか

次に、抽出したオブジェクトに新しい名前をつける。

## 混乱したオブジェクト
肥大化したコンストラクタの症例のひとつで、ひとつのオブジェクトがあまりにも多くの責務を持ちすぎているために起こる。  
複数のオブジェクトに分離すること。テストも複数の関係のない機能のテストが混じって見通しが悪くなる。

## 多すぎる依存関係
肥大化したコンストラクタの症例の一つで、依存ピア以外をコンストラクタで渡そうとすると発生する。  
通知ピアや調整ピアはデフォルト値を設定しておけば良い。依存ピアだけが、それがないとオブジェクトが機能しない、という性格のピアだからだろう。

## 多すぎるエクスペくテーション
何が重要かがはっきりしなくなる。外部に副作用を及ぼす呼び出しにのみエクスペくテーションを行うのが良い。

## テストが教えてくれること
* 知識をローカルに保つ
* 明示的にすれば、名前をつけることができる
* 名前をつければつけるほど、ドメイン情報が増える
* データではなく振る舞いを渡す